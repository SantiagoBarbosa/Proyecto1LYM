/**
 * JavaCC file
 *   Implements a parser for the following grammar
 *       < program > ::=   BEGIN   (< PropName >  =  < value >)*  END
 *        < PropName > ::=   ONE | TWO | THREE |  FOUR
 *        < Value >  ::=     number  |  name
 *   We have a contstraint that must be checked ehen parsing:  there cannot be more than one value assigned to the same  property
 */
options {
  IGNORE_CASE = true;
  STATIC = false;
}
PARSER_BEGIN(Simple)
package uniandes.teolen.parserJavaCC.parserProyecto1;

import java.util.HashMap; 
import java.util.Map;
 
public class Simple {



String []  names = { "title", "author", "journal", "year","volume","editor", "number",
 "pages", "month","doi", "note","key","publisher","series","address", "edition", "url","howPublished", "type", "chapter", "organization"  };

HashMap<String, Object> map = new HashMap<String, Object>();

} 

PARSER_END(Simple)

SKIP :
{
 	" " | "\r" | "\t" | "\n"

}
TOKEN : /* OPERATORS */
{
   < BIBTYPE : "article"
  | "book" 
  | "booklet" 
  | "conference" 
  | "inbook"
  | "incollection"
  | "inproceedings"
  |  "manual"
  |"mastersthesis"
  |"misc" 
|"phdthesis"
|"proceedings"
| "techreport"
| "unpublished">
 |    <END: "END">
 | < TITLE:("title")>
 | < AUTHOR:("author")>
 | < JOURNAL:("journal") >
 |< YEAR:  ("year") >
 |< VOLUME:("volume") >
 |< EDITOR:("editor") >
 | < NUMBER:( "number") >
 | < PGS:("pages") > |< MONTH:("month") >|< DPI:("doi") >|< NOTE: ("note") >|< KEY:("key") >
 |< PUBLISHER:("publisher") >|< SERIES:("series") >|< ADDRESS:("address") >
 |< EDITION:(  "edition") >|< URL:( "url") >|< HPUBLISH:("howPublished") >
 |< TYP: ("type") >|< CHAPTER:  ("chapter") >|< ORGA:( "organization") >
	|  < #DIGIT: "0" | "1" | "2"| "3" | "4" | "5" |  "6" | "7" | "8" |"9" >
	|   < INT: ( <DIGIT> )( <DIGIT> )* >
	|   < NAME: ["a"-"z"] (["a"-"z"] | <DIGIT> )* >
   
   
}
void exp() throws Error:
{
}
{
< TITLE > "={" value(names[0])"}"  
| < JOURNAL > "={"value(names[2])"}"
| < AUTHOR > "={"value(names[1])"}"
| < YEAR > "={"value(names[3])"}"
| < VOLUME > "={"value(names[4])"}"
| < EDITOR > "={"value(names[5])"}"
| < NUMBER > "={"value(names[6])"}"
| < PGS >"={"value(names[7])"}"
|< MONTH >"={"value(names[8])"}"
|< DPI >"={"value(names[9])"}"
| < NOTE >"={"value(names[10])"}"
|< KEY >"={"value(names[11])"}"
|< PUBLISHER >"={"value(names[12])"}"
|< SERIES >"={"value(names[13])"}"
|< ADDRESS >"={"value(names[14])"}"
| < EDITION >"={"value(names[15])"}"
 |< URL >"={"value(names[16])"}" |< HPUBLISH >"={"value(names[17])"}" |< TYP > "={"value(names[18])"}"| < CHAPTER >"={"value(names[19])"}" |< ORGA >"={"value(names[20])"}" 
  
}

HashMap<String, Object> simple()  throws  Error:
{
  Token token;
  Token token2;
  }
 
{
 token=< BIBTYPE >"{"token2 = < NAME>","   
(exp() ("," exp())*)  "};" < END >

 
   
{
  
System.out.println("analizando el :  "+ token.image + " con ID: "+token2.image);
System.out.println("number of  properties set:  "+ map.size());
for (int i = 0; i < 1000; i++) {
  if  (map.containsKey(names[i]))
  	System.out.println(names[i] +  "=" + (map.get(names[i])).toString());
  else
    System.out.println(names[i] + ":  No value assigned !!!!" );
}
return map;

}

}

 
void value(String name) throws Error:
{	
	int total=1;
	Token token;
}

{
    { if (map.containsKey(name))
         throw new Error("Duplicate property: " + name);
    }

	(token = <INT>

	{ 
		try {
			total = Integer.parseInt(token.image);
		} 
		catch (NumberFormatException ee) 
		{
			// We know that <INT>  is composed of digits;
			// The only possible error is that the sequenceï¿½s value is too large 
			throw new Error("Number too large: "+token.image);
		}
		map.put(name,new Integer(total));
     }
| 
    token=<NAME>
    { map.put(name,new String(token.image));}
  
)   
     
}